// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'app_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AppState {
  String? get ipCurrency => throw _privateConstructorUsedError;
  String? get opCurrency => throw _privateConstructorUsedError;
  String? get ipOne => throw _privateConstructorUsedError;
  String? get ipTwo => throw _privateConstructorUsedError;
  bool get ipOneError => throw _privateConstructorUsedError;
  bool get ipTwoError => throw _privateConstructorUsedError;
  String? get error => throw _privateConstructorUsedError;
  bool get cached => throw _privateConstructorUsedError;
  bool get offline => throw _privateConstructorUsedError;
  Map<String, String>? get currencies => throw _privateConstructorUsedError;
  Operation? get operation => throw _privateConstructorUsedError;
  bool get operationError => throw _privateConstructorUsedError;
  bool get ipCurrencyError => throw _privateConstructorUsedError;
  bool get opCurrencyError => throw _privateConstructorUsedError;
  bool get currencyFetchError => throw _privateConstructorUsedError;
  bool get calculating => throw _privateConstructorUsedError;
  String? get calculationResult => throw _privateConstructorUsedError;
  String? get conversionResult => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AppStateCopyWith<AppState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppStateCopyWith<$Res> {
  factory $AppStateCopyWith(AppState value, $Res Function(AppState) then) =
      _$AppStateCopyWithImpl<$Res, AppState>;
  @useResult
  $Res call(
      {String? ipCurrency,
      String? opCurrency,
      String? ipOne,
      String? ipTwo,
      bool ipOneError,
      bool ipTwoError,
      String? error,
      bool cached,
      bool offline,
      Map<String, String>? currencies,
      Operation? operation,
      bool operationError,
      bool ipCurrencyError,
      bool opCurrencyError,
      bool currencyFetchError,
      bool calculating,
      String? calculationResult,
      String? conversionResult});
}

/// @nodoc
class _$AppStateCopyWithImpl<$Res, $Val extends AppState>
    implements $AppStateCopyWith<$Res> {
  _$AppStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ipCurrency = freezed,
    Object? opCurrency = freezed,
    Object? ipOne = freezed,
    Object? ipTwo = freezed,
    Object? ipOneError = null,
    Object? ipTwoError = null,
    Object? error = freezed,
    Object? cached = null,
    Object? offline = null,
    Object? currencies = freezed,
    Object? operation = freezed,
    Object? operationError = null,
    Object? ipCurrencyError = null,
    Object? opCurrencyError = null,
    Object? currencyFetchError = null,
    Object? calculating = null,
    Object? calculationResult = freezed,
    Object? conversionResult = freezed,
  }) {
    return _then(_value.copyWith(
      ipCurrency: freezed == ipCurrency
          ? _value.ipCurrency
          : ipCurrency // ignore: cast_nullable_to_non_nullable
              as String?,
      opCurrency: freezed == opCurrency
          ? _value.opCurrency
          : opCurrency // ignore: cast_nullable_to_non_nullable
              as String?,
      ipOne: freezed == ipOne
          ? _value.ipOne
          : ipOne // ignore: cast_nullable_to_non_nullable
              as String?,
      ipTwo: freezed == ipTwo
          ? _value.ipTwo
          : ipTwo // ignore: cast_nullable_to_non_nullable
              as String?,
      ipOneError: null == ipOneError
          ? _value.ipOneError
          : ipOneError // ignore: cast_nullable_to_non_nullable
              as bool,
      ipTwoError: null == ipTwoError
          ? _value.ipTwoError
          : ipTwoError // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      cached: null == cached
          ? _value.cached
          : cached // ignore: cast_nullable_to_non_nullable
              as bool,
      offline: null == offline
          ? _value.offline
          : offline // ignore: cast_nullable_to_non_nullable
              as bool,
      currencies: freezed == currencies
          ? _value.currencies
          : currencies // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      operation: freezed == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as Operation?,
      operationError: null == operationError
          ? _value.operationError
          : operationError // ignore: cast_nullable_to_non_nullable
              as bool,
      ipCurrencyError: null == ipCurrencyError
          ? _value.ipCurrencyError
          : ipCurrencyError // ignore: cast_nullable_to_non_nullable
              as bool,
      opCurrencyError: null == opCurrencyError
          ? _value.opCurrencyError
          : opCurrencyError // ignore: cast_nullable_to_non_nullable
              as bool,
      currencyFetchError: null == currencyFetchError
          ? _value.currencyFetchError
          : currencyFetchError // ignore: cast_nullable_to_non_nullable
              as bool,
      calculating: null == calculating
          ? _value.calculating
          : calculating // ignore: cast_nullable_to_non_nullable
              as bool,
      calculationResult: freezed == calculationResult
          ? _value.calculationResult
          : calculationResult // ignore: cast_nullable_to_non_nullable
              as String?,
      conversionResult: freezed == conversionResult
          ? _value.conversionResult
          : conversionResult // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppStateCopyWith<$Res> implements $AppStateCopyWith<$Res> {
  factory _$$_AppStateCopyWith(
          _$_AppState value, $Res Function(_$_AppState) then) =
      __$$_AppStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? ipCurrency,
      String? opCurrency,
      String? ipOne,
      String? ipTwo,
      bool ipOneError,
      bool ipTwoError,
      String? error,
      bool cached,
      bool offline,
      Map<String, String>? currencies,
      Operation? operation,
      bool operationError,
      bool ipCurrencyError,
      bool opCurrencyError,
      bool currencyFetchError,
      bool calculating,
      String? calculationResult,
      String? conversionResult});
}

/// @nodoc
class __$$_AppStateCopyWithImpl<$Res>
    extends _$AppStateCopyWithImpl<$Res, _$_AppState>
    implements _$$_AppStateCopyWith<$Res> {
  __$$_AppStateCopyWithImpl(
      _$_AppState _value, $Res Function(_$_AppState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ipCurrency = freezed,
    Object? opCurrency = freezed,
    Object? ipOne = freezed,
    Object? ipTwo = freezed,
    Object? ipOneError = null,
    Object? ipTwoError = null,
    Object? error = freezed,
    Object? cached = null,
    Object? offline = null,
    Object? currencies = freezed,
    Object? operation = freezed,
    Object? operationError = null,
    Object? ipCurrencyError = null,
    Object? opCurrencyError = null,
    Object? currencyFetchError = null,
    Object? calculating = null,
    Object? calculationResult = freezed,
    Object? conversionResult = freezed,
  }) {
    return _then(_$_AppState(
      ipCurrency: freezed == ipCurrency
          ? _value.ipCurrency
          : ipCurrency // ignore: cast_nullable_to_non_nullable
              as String?,
      opCurrency: freezed == opCurrency
          ? _value.opCurrency
          : opCurrency // ignore: cast_nullable_to_non_nullable
              as String?,
      ipOne: freezed == ipOne
          ? _value.ipOne
          : ipOne // ignore: cast_nullable_to_non_nullable
              as String?,
      ipTwo: freezed == ipTwo
          ? _value.ipTwo
          : ipTwo // ignore: cast_nullable_to_non_nullable
              as String?,
      ipOneError: null == ipOneError
          ? _value.ipOneError
          : ipOneError // ignore: cast_nullable_to_non_nullable
              as bool,
      ipTwoError: null == ipTwoError
          ? _value.ipTwoError
          : ipTwoError // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      cached: null == cached
          ? _value.cached
          : cached // ignore: cast_nullable_to_non_nullable
              as bool,
      offline: null == offline
          ? _value.offline
          : offline // ignore: cast_nullable_to_non_nullable
              as bool,
      currencies: freezed == currencies
          ? _value._currencies
          : currencies // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      operation: freezed == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as Operation?,
      operationError: null == operationError
          ? _value.operationError
          : operationError // ignore: cast_nullable_to_non_nullable
              as bool,
      ipCurrencyError: null == ipCurrencyError
          ? _value.ipCurrencyError
          : ipCurrencyError // ignore: cast_nullable_to_non_nullable
              as bool,
      opCurrencyError: null == opCurrencyError
          ? _value.opCurrencyError
          : opCurrencyError // ignore: cast_nullable_to_non_nullable
              as bool,
      currencyFetchError: null == currencyFetchError
          ? _value.currencyFetchError
          : currencyFetchError // ignore: cast_nullable_to_non_nullable
              as bool,
      calculating: null == calculating
          ? _value.calculating
          : calculating // ignore: cast_nullable_to_non_nullable
              as bool,
      calculationResult: freezed == calculationResult
          ? _value.calculationResult
          : calculationResult // ignore: cast_nullable_to_non_nullable
              as String?,
      conversionResult: freezed == conversionResult
          ? _value.conversionResult
          : conversionResult // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_AppState implements _AppState {
  const _$_AppState(
      {this.ipCurrency,
      this.opCurrency,
      this.ipOne,
      this.ipTwo,
      this.ipOneError = false,
      this.ipTwoError = false,
      this.error,
      this.cached = false,
      this.offline = false,
      final Map<String, String>? currencies,
      this.operation,
      this.operationError = false,
      this.ipCurrencyError = false,
      this.opCurrencyError = false,
      this.currencyFetchError = false,
      this.calculating = false,
      this.calculationResult,
      this.conversionResult})
      : _currencies = currencies;

  @override
  final String? ipCurrency;
  @override
  final String? opCurrency;
  @override
  final String? ipOne;
  @override
  final String? ipTwo;
  @override
  @JsonKey()
  final bool ipOneError;
  @override
  @JsonKey()
  final bool ipTwoError;
  @override
  final String? error;
  @override
  @JsonKey()
  final bool cached;
  @override
  @JsonKey()
  final bool offline;
  final Map<String, String>? _currencies;
  @override
  Map<String, String>? get currencies {
    final value = _currencies;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final Operation? operation;
  @override
  @JsonKey()
  final bool operationError;
  @override
  @JsonKey()
  final bool ipCurrencyError;
  @override
  @JsonKey()
  final bool opCurrencyError;
  @override
  @JsonKey()
  final bool currencyFetchError;
  @override
  @JsonKey()
  final bool calculating;
  @override
  final String? calculationResult;
  @override
  final String? conversionResult;

  @override
  String toString() {
    return 'AppState(ipCurrency: $ipCurrency, opCurrency: $opCurrency, ipOne: $ipOne, ipTwo: $ipTwo, ipOneError: $ipOneError, ipTwoError: $ipTwoError, error: $error, cached: $cached, offline: $offline, currencies: $currencies, operation: $operation, operationError: $operationError, ipCurrencyError: $ipCurrencyError, opCurrencyError: $opCurrencyError, currencyFetchError: $currencyFetchError, calculating: $calculating, calculationResult: $calculationResult, conversionResult: $conversionResult)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppState &&
            (identical(other.ipCurrency, ipCurrency) ||
                other.ipCurrency == ipCurrency) &&
            (identical(other.opCurrency, opCurrency) ||
                other.opCurrency == opCurrency) &&
            (identical(other.ipOne, ipOne) || other.ipOne == ipOne) &&
            (identical(other.ipTwo, ipTwo) || other.ipTwo == ipTwo) &&
            (identical(other.ipOneError, ipOneError) ||
                other.ipOneError == ipOneError) &&
            (identical(other.ipTwoError, ipTwoError) ||
                other.ipTwoError == ipTwoError) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.cached, cached) || other.cached == cached) &&
            (identical(other.offline, offline) || other.offline == offline) &&
            const DeepCollectionEquality()
                .equals(other._currencies, _currencies) &&
            (identical(other.operation, operation) ||
                other.operation == operation) &&
            (identical(other.operationError, operationError) ||
                other.operationError == operationError) &&
            (identical(other.ipCurrencyError, ipCurrencyError) ||
                other.ipCurrencyError == ipCurrencyError) &&
            (identical(other.opCurrencyError, opCurrencyError) ||
                other.opCurrencyError == opCurrencyError) &&
            (identical(other.currencyFetchError, currencyFetchError) ||
                other.currencyFetchError == currencyFetchError) &&
            (identical(other.calculating, calculating) ||
                other.calculating == calculating) &&
            (identical(other.calculationResult, calculationResult) ||
                other.calculationResult == calculationResult) &&
            (identical(other.conversionResult, conversionResult) ||
                other.conversionResult == conversionResult));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      ipCurrency,
      opCurrency,
      ipOne,
      ipTwo,
      ipOneError,
      ipTwoError,
      error,
      cached,
      offline,
      const DeepCollectionEquality().hash(_currencies),
      operation,
      operationError,
      ipCurrencyError,
      opCurrencyError,
      currencyFetchError,
      calculating,
      calculationResult,
      conversionResult);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppStateCopyWith<_$_AppState> get copyWith =>
      __$$_AppStateCopyWithImpl<_$_AppState>(this, _$identity);
}

abstract class _AppState implements AppState {
  const factory _AppState(
      {final String? ipCurrency,
      final String? opCurrency,
      final String? ipOne,
      final String? ipTwo,
      final bool ipOneError,
      final bool ipTwoError,
      final String? error,
      final bool cached,
      final bool offline,
      final Map<String, String>? currencies,
      final Operation? operation,
      final bool operationError,
      final bool ipCurrencyError,
      final bool opCurrencyError,
      final bool currencyFetchError,
      final bool calculating,
      final String? calculationResult,
      final String? conversionResult}) = _$_AppState;

  @override
  String? get ipCurrency;
  @override
  String? get opCurrency;
  @override
  String? get ipOne;
  @override
  String? get ipTwo;
  @override
  bool get ipOneError;
  @override
  bool get ipTwoError;
  @override
  String? get error;
  @override
  bool get cached;
  @override
  bool get offline;
  @override
  Map<String, String>? get currencies;
  @override
  Operation? get operation;
  @override
  bool get operationError;
  @override
  bool get ipCurrencyError;
  @override
  bool get opCurrencyError;
  @override
  bool get currencyFetchError;
  @override
  bool get calculating;
  @override
  String? get calculationResult;
  @override
  String? get conversionResult;
  @override
  @JsonKey(ignore: true)
  _$$_AppStateCopyWith<_$_AppState> get copyWith =>
      throw _privateConstructorUsedError;
}
